---
alwaysApply: true
---

 You are an expert in JavaScript, TypeScript, React, Node.js, Vite, React Router, Zustand, Shadcn UI, Radix UI, and Tailwind CSS.

  Code Style and Structure
  - Write concise, technical JavaScript code following Standard.js rules.
  - Use functional and declarative programming patterns; avoid classes.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
  - Structure files: exported component, subcomponents, helpers, static content.

  Standard.js Rules
  - Use 2 space indentation.
  - Use single quotes for strings except to avoid escaping.
  - No semicolons (unless required to disambiguate statements).
  - No unused variables.
  - Add a space after keywords.
  - Add a space before a function declaration's parentheses.
  - Always use === instead of ==.
  - Infix operators must be spaced.
  - Commas should have a space after them.
  - Keep else statements on the same line as their curly braces.
  - For multi-line if statements, use curly braces.
  - Always handle the err function parameter.
  - Use camelcase for variables and functions.
  - Use PascalCase for constructors and React components.

  Naming Conventions
  - Use lowercase with dashes for directories (e.g., components/auth-wizard).
  - Favor named exports for components.

  React Best Practices
  - Use functional components with TypeScript for type checking.
  - Use the "function" keyword for component definitions.
  - Implement hooks correctly (useState, useEffect, useContext, useReducer, useMemo, useCallback).
  - Follow the Rules of Hooks (only call hooks at the top level, only call hooks from React functions).
  - Create custom hooks to extract reusable component logic.
  - Use React.memo() for component memoization when appropriate.
  - Implement useCallback for memoizing functions passed as props.
  - Use useMemo for expensive computations.
  - Avoid inline function definitions in render to prevent unnecessary re-renders.
  - Prefer composition over inheritance.
  - Use children prop and render props pattern for flexible, reusable components.
  - Implement React.lazy() and Suspense for code splitting.
  - Use refs sparingly and mainly for DOM access.
  - Prefer controlled components over uncontrolled components.
  - Implement error boundaries to catch and handle errors gracefully.
  - Use cleanup functions in useEffect to prevent memory leaks.
  - Use short-circuit evaluation and ternary operators for conditional rendering.

  State Management
  - Use Zustand for global state management.
  - Lift state up when needed to share state between components.
  - Use context for intermediate state sharing when prop drilling becomes cumbersome.

  UI and Styling
  - Use Shadcn UI and Radix UI for component foundations.
  - Implement responsive design with Tailwind CSS; use a mobile-first approach.
  - Use Tailwind CSS utility classes for styling.
  - For component-specific styles, use CSS Modules (.module.css) or inline styles when necessary.
  - Never use the @apply directive in Tailwind.
  - Use Tailwind's design tokens and configuration for consistent spacing, colors, and typography.

  Performance Optimization
  - Minimize 'useEffect' and 'useState' when possible; prefer derived state and composition.
  - Wrap components in Suspense with fallback for code splitting.
  - Use React.lazy() and dynamic imports for route-based code splitting with React Router.
  - Optimize images: use WebP format, include size data, implement lazy loading.
  - Leverage Vite's built-in code splitting and optimization features.
  - Minimize the use of global styles; prefer Tailwind utility classes and CSS Modules.
  - Tailwind automatically purges unused styles in production builds.

  Forms and Validation
  - Use controlled components for form inputs.
  - Implement form validation (client-side and server-side).
  - Consider using libraries like react-hook-form for complex forms.
  - Use Zod or Joi for schema validation.

  Error Handling and Validation
  - Prioritize error handling and edge cases.
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Use try-catch blocks for async operations and provide fallback UI.

  Accessibility (a11y)
  - Use semantic HTML elements.
  - Implement proper ARIA attributes.
  - Ensure keyboard navigation support.

  Testing
  - Follow Test-Driven Development (TDD) principles: write tests before implementation when appropriate (Red-Green-Refactor cycle).
  - Write unit tests for components using Jest and React Testing Library.
  - Test user interactions and component behavior, not implementation details.
  - Prioritize accessibility-focused queries (getByRole, getByLabelText) from React Testing Library.
  - Write tests for utility functions, custom hooks, and business logic first using TDD.
  - Mock external dependencies, API calls, and browser APIs in tests.
  - Implement integration tests for critical user flows.
  - Use snapshot testing judiciously and for UI regression testing.
  - Keep tests isolated, fast, and independent from each other.
  - Use descriptive test names that explain the expected behavior.

  Security
  - Sanitize user inputs to prevent XSS attacks.
  - Use dangerouslySetInnerHTML sparingly and only with sanitized content.

  Internationalization (i18n)
  - Use i18next and react-i18next for internationalization.
  - Organize translation files in the i18n/locales directory.

  Key Conventions
  - Use React Router for routing and navigation.
  - Use URL search parameters with React Router's useSearchParams hook when needed.
  - Optimize Web Vitals (LCP, CLS, FID, INP).
  - Use Vite for build tooling and development server.
  - Leverage React Router's data loading features (loaders, actions) when appropriate.
  - Use Tailwind utility classes for rapid development and consistent spacing/sizing.
  - Prefer TypeScript for type safety throughout the codebase.

  Routing and Data Fetching
  - Use React Router for client-side routing.
  - Implement route-based code splitting with React.lazy().
  - Use React Router loaders and actions for data fetching when using React Router v6.4+.
  - For API calls, use async/await with proper error handling.

  Project Structure
  - Organize files by feature/domain rather than by type (feature-based architecture).
  - Use index.ts files for clean imports and barrel exports.
  - Keep components, hooks, utils, and types in separate directories within features.
  - Use consistent naming: lowercase with dashes for directories, PascalCase for components.
  - Place shared/common code in a shared or common directory.
  - Keep configuration files at the root level.
  - Use .env files for environment-specific configurations.

  Development Workflow
  - Use Git flow or GitHub flow for branching strategy.
  - Create feature branches from main/develop for new features.
  - Use descriptive commit messages in Korean with conventional commits format.
  - Follow conventional commits pattern: `type(scope): description`
  - Common commit types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
  - Write commit messages that clearly explain what was changed and why.
  - Keep commit messages under 50 characters for the first line.
  - Use imperative mood for commit messages (e.g., "Add feature" not "Added feature").
  - Implement pre-commit hooks for code quality checks (linting, formatting).
  - Use semantic versioning for releases.
  - Maintain a changelog for version tracking.
  - Set up automated testing in CI/CD pipeline.

  Build and Deployment
  - Configure Vite for different environments (development, staging, production).
  - Use environment variables for API endpoints, feature flags, and secrets.
  - Implement proper build optimization (code splitting, tree shaking, minification).
  - Set up CI/CD pipeline with automated testing and deployment.
  - Use Docker for containerization when deploying to cloud platforms.
  - Implement health checks and monitoring for production deployments.
  - Configure proper caching strategies for static assets.

  Code Quality and Documentation
  - Maintain comprehensive README with setup, development, and deployment instructions.
  - Document complex business logic and architectural decisions.
  - Use JSDoc or TSDoc for public API documentation.
  - Implement code review checklists and standards.
  - Regularly audit and update dependencies for security vulnerabilities.
  - Maintain coding standards and style guides.
  - Use tools like Storybook for component documentation and testing.

  Monitoring and Analytics
  - Implement error tracking with services like Sentry or LogRocket.
  - Set up application monitoring and alerting.
  - Track user interactions and conversion funnels.
  - Monitor performance metrics and Web Vitals.
  - Implement logging for debugging and troubleshooting.
  - Use analytics to understand user behavior and improve UX.

  Shared Components Usage
  - Use the established shadcn/ui component library for consistent UI across projects.
  - Import components from the centralized location: `import { Button, Card } from '@/components/ui'`.
  - Extend existing components by wrapping them with custom logic or styling when needed.
  - Follow the established variant and size patterns for component customization.
  - Create project-specific components in the project's `components/` folder for unique requirements.
  - Maintain component prop interfaces - avoid breaking changes to shared components.
  - Document any custom extensions or modifications to shared components.
  - Use TypeScript for all component definitions to ensure type safety across projects.
  - Test components thoroughly before adding to the shared library.
  - Consider creating feature-specific component folders when components become numerous.
  - Keep the shared component library lightweight and focused on reusable primitives.

  Component Development Guidelines
  - Build upon existing shadcn/ui components rather than recreating basic UI elements.
  - Use the `cn()` utility function for consistent className merging across all components.
  - Implement proper TypeScript interfaces for all component props.
  - Include accessibility features (ARIA attributes, keyboard navigation) in custom components.
  - Use forwardRef when DOM access is needed by parent components.
  - Document component usage with JSDoc comments for better developer experience.
  - Follow the established naming conventions: PascalCase for components, camelCase for props.
  - Implement proper error boundaries for complex components.
  - Use React.memo() for performance optimization when appropriate.
  - Keep components focused on single responsibilities.

  Design System Consistency
  - Adhere to the established Tailwind CSS design tokens for colors, spacing, and typography.
  - Use the theme system (light/dark mode) consistently across all components.
  - Maintain consistent spacing using the predefined spacing scale.
  - Follow the established component sizing patterns (sm, md, lg variants).
  - Use semantic color naming (primary, secondary, destructive) for consistent theming.
  - Implement responsive design patterns consistently across components.
  - Document design decisions and component usage patterns for team alignment.